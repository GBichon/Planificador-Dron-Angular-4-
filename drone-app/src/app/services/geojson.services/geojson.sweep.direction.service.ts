import { GeoJson_Polygon_Service } from './geojson.polygon.service';
import { GeoJson_Sweep_Cost_Service } from './geojson.sweep.cost.service';
declare var turf: any;

export class GeoJson_Sweep_Direction_Service {

  constructor(){}

  /**
   * Determine the optimal coverage direction for a GeoJSON polygon out of a list of
   * angles. These angles are generated by starting from the 'start' value and
   * increasing its value by 'increment' until 'end' value is reached.
   * Optionally, it can also use the edge angles of the given polygon.
   * @param  polygon   Any GeoJSON Polygon
   * @param  start     Minimum angle accepted
   * @param  end       Maximum angle accepted
   * @param  increment Step Value
   * @param  passWidth Width of the pass
   * @param  options   [options = {}]
   *                   [options.useEdges] = flag that determines if the edge angles will be also used when computing the optimal coverage direction
   *                   [options.roundPrecision] = rounding precision of the angles
   *                   [options.cost1] = cost of the first part of the cost function
   *                   [options.cost2] = cost of the second part of the cost function
   *                   [options.cost3] = cost of the third part of the cost function
   * @return           [return.optimalAngle] = Optimal coverage direction
   *                   [return.optimalCost] = Optimal coverage cost by following the optimal direction
   */
  public determineOptimalSweepDirectionFromAngleRange(polygon: any, start: number, end: number, increment: number, passWidth: number, options?: any ): any{

    // Services declaration
    const PolygonService = new GeoJson_Polygon_Service();
    const CostService = new GeoJson_Sweep_Cost_Service();

    // Optional parameters, default values handling
    if (options == void 0) { options = {}; }
    if (!options.hasOwnProperty("useEdges")) { options.useEdges = false; };

    // Validations
    if (turf.getType(polygon) !== "Polygon")
      throw new Error("A GeoJSON Polygon object is required");

    if (start < 0 || start >= 180)
      throw new Error("'start' must be a value between 0 and 180, not including the last one");

    if (end <= 0 || end > 180)
      throw new Error("'end' must be a value between 0 and 180, not including the first one");

    if (start > end)
      throw new Error("'start' can't be greater than 'end'");

    if (increment <= 0)
      throw new Error("'increment' must be a positive value");

    if (typeof options.useEdges !== "boolean")
      throw new Error("Optional parameter 'useEdges' must be a boolean");

    if (options.roundingPrecision && typeof options.roundingPrecision !== "number")
      throw new Error("Optional parameter 'roundingPrecision' must be a number");

    if (options.roundingPrecision && options.roundingPrecision < 0)
      throw new Error("Optional parameter 'roundingPrecision' must be zero or a positive value");

    if (options.roundingPrecision && !Number.isInteger(options.roundingPrecision))
      throw new Error("Optional parameter 'roundingPrecision' must be an Integer value");

    // Prepare the array of angles
    let angles = [];
    for (let angle = start; angle < end; angle += increment) {
      angles.push((options.roundingPrecision)? turf.round(angle, options.roundingPrecision) : angle)
    };

    // Optionally, also get the angles of the edges
    if (options.useEdges){ angles = angles.concat(PolygonService.getAngles(polygon)); }

    // Calculate the cost function of each angle and keep the optimal
    let optimalAngle = null, optimalCost = null;
    angles.forEach( angle => {
      let totalCost = CostService.computeCostFunctionOnPolygon(polygon, angle, passWidth, options);
      if (optimalCost === null || totalCost < optimalCost){
        optimalCost = totalCost, optimalAngle = angle;
      }
    })

    // Return value
    return {optimalCost: optimalCost, optimalAngle: optimalAngle};
  }



  /**
   * Determine the optimal coverage direction for a GeoJSON polygon out of the
   * list of angles generated from the polygon edges
   * @param  polygon    Any GeoJSON Polygon
   * @param  passWidth  Width of the pass
   * @param  options    [options = {}]
   *                    [options.roundPrecision] = rounding precision of the angles
   *                    [options.cost1] = cost of the first part of the cost function
   *                    [options.cost2] = cost of the second part of the cost function
   *                    [options.cost3] = cost of the third part of the cost function
   * @return            [return.optimalAngle] = Optimal coverage direction
   *                    [return.optimalCost] = Optimal coverage cost by following the optimal direction
   */
  public determineOptimalSweepDirection(polygon: any, passWidth: number, options?: any): any{

    // Services declaration
    const PolygonService = new GeoJson_Polygon_Service();
    const CostService = new GeoJson_Sweep_Cost_Service();

    // Optional parameters, default values handling
    if (options == void 0) { options = {}; }

    // Validations
    if (turf.getType(polygon) !== "Polygon")
      throw new Error("A GeoJSON Polygon object is required")

    if (options.roundingPrecision && typeof options.roundingPrecision !== "number")
      throw new Error("Optional parameter 'roundingPrecision' must be a number");

    if (options.roundingPrecision && options.roundingPrecision < 0)
      throw new Error("Optional parameter 'roundingPrecision' must be zero or a positive value");

    if (options.roundingPrecision && !Number.isInteger(options.roundingPrecision))
      throw new Error("Optional parameter 'roundingPrecision' must be an Integer value");

    // Obtain every polygon angle
    let angles = PolygonService.getAngles(polygon);

    // Calculate the cost function of each angle and keeps the optimal
    let optimalAngle = null, optimalCost = null;
    angles.forEach( angle => {
      let totalCost = CostService.computeCostFunctionOnPolygon(polygon, angle, passWidth, options);
      if (optimalCost === null || totalCost < optimalCost){
        optimalCost = totalCost, optimalAngle = angle;
      }
    });

    // Return value
    return {optimalCost: optimalCost, optimalAngle: optimalAngle};
  }


}
